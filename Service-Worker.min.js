const CACHE_NAME = "versao.3.0.0", OFFLINE_URL = "/Paginas/PaginaErros/PaginaErros.html", STATIC_DESTINATIONS = ["style", "script", "image"], PRECACHE_URLS = [OFFLINE_URL, "Manifest.json", "/Paginas/CarregarPagina.min.js", "/Layout/Imagens/Logotipos/Logotipo.svg", "/Layout/Imagens/Logotipos/Icone.ico", "/Layout/Imagens/Logotipos/Cookies.svg", "/Layout/Imagens/Icones/linkedin.svg", "/Layout/Imagens/Icones/facebook.svg", "/Layout/Imagens/Icones/youtube.svg", "/Layout/Externos/Filtros.min.css", "favicon.ico"], DB_NAME = "pwa-sync", STORE_NAME = "requests"; function openDatabase() { return new Promise((e, t) => { const s = indexedDB.open(DB_NAME, 1); s.onupgradeneeded = () => { s.result.createObjectStore("requests", { autoIncrement: !0 }) }, s.onsuccess = () => e(s.result), s.onerror = () => t(s.error) }) } async function savePostRequest(e) { const t = (await openDatabase()).transaction("requests", "readwrite"), s = t.objectStore("requests"), n = []; for (const [t, s] of e.headers.entries()) n.push([t, s]); const a = await e.clone().text(); return s.add({ url: e.url, method: e.method, headers: n, body: a }), new Promise((e, s) => { t.oncomplete = e, t.onerror = () => s(t.error) }) } async function listQueuedRequests() { const e = (await openDatabase()).transaction("requests", "readonly"), t = e.objectStore("requests"), s = await (n = t.getAll(), new Promise((e, t) => { n.onsuccess = () => e(n.result), n.onerror = () => t(n.error) })); var n; return new Promise((t, n) => { e.oncomplete = () => t(s), e.onerror = () => n(e.error) }) } async function replayQueuedRequests() { const e = (await openDatabase()).transaction("requests", "readwrite"), t = e.objectStore("requests"), s = e => new Promise((t, s) => { e.onsuccess = () => t(e.result), e.onerror = () => s(e.error) }), n = await s(t.getAll()), a = await s(t.getAllKeys()); return await Promise.all(n.map((e, s) => { const n = a[s]; return fetch(e.url, { method: e.method, headers: new Headers(e.headers), body: e.body }).then(() => t.delete(n)).catch(() => { }) })), new Promise((t, s) => { e.oncomplete = t, e.onerror = () => s(e.error) }) } async function cacheFirst(e) { const t = await caches.open(CACHE_NAME), s = await t.match(e); if (s) return fetch(e).then(s => t.put(e, s.clone())).catch(() => { }), s; try { const s = await fetch(e); return "GET" === e.method && t.put(e, s.clone()), s } catch { return caches.match(OFFLINE_URL) } } async function staleWhileRevalidate(e) { const t = await caches.open(CACHE_NAME), s = await t.match(e), n = fetch(e).then(s => (t.put(e, s.clone()), s)).catch(() => { }); return s || n.then(e => e).catch(() => caches.match(OFFLINE_URL)) } async function networkFirst(e) { const t = await caches.open(CACHE_NAME); try { const s = await fetch(e); return t.put(e, s.clone()), s } catch { return await t.match(e) || caches.match(OFFLINE_URL) } } self.addEventListener("install", e => { e.waitUntil(caches.open(CACHE_NAME).then(e => e.addAll(PRECACHE_URLS))), self.skipWaiting() }), self.addEventListener("message", e => { !e.data || "skipWaiting" !== e.data && "skipWaiting" !== e.data.type ? e.data && "getQueuedRequests" === e.data.type && e.waitUntil(listQueuedRequests().then(t => { e.ports[0]?.postMessage({ requests: t }) })) : self.skipWaiting() }), self.addEventListener("activate", e => { e.waitUntil(caches.keys().then(e => Promise.all(e.filter(e => e !== CACHE_NAME).map(e => caches.delete(e)))).then(() => self.clients.claim()).then(() => self.clients.matchAll({ type: "window", includeUncontrolled: !0 })).then(e => { e.forEach(e => e.postMessage({ type: "updated", version: CACHE_NAME })) })) }), self.addEventListener("fetch", e => { const { request: t } = e, s = new URL(t.url); s.origin === location.origin ? "navigate" === t.mode ? e.respondWith(networkFirst(t)) : "POST" === t.method ? e.respondWith(fetch(t.clone()).catch(() => savePostRequest(t).then(() => ("sync" in self.registration && self.registration.sync.register("sync-requests").catch(() => { }), self.clients.matchAll({ type: "window" }).then(e => { e.forEach(e => e.postMessage({ type: "offline-request", url: t.url })) }), new Response(JSON.stringify({ offline: !0 }), { headers: { "Content-Type": "application/json" } }))))) : "GET" === t.method && (s.pathname.startsWith("/Paginas/Seletores/") || ["style", "script"].includes(t.destination) ? e.respondWith(staleWhileRevalidate(t)) : "image" === t.destination ? e.respondWith(cacheFirst(t)) : e.respondWith(networkFirst(t))) : e.respondWith(fetch(t)) }), self.addEventListener("sync", e => { "sync-requests" === e.tag && e.waitUntil(replayQueuedRequests()) }), self.addEventListener("periodicsync", e => { "update-content" === e.tag && e.waitUntil(fetch("/").then(e => caches.open(CACHE_NAME).then(t => t.put("/", e.clone()))).catch(() => { })) });